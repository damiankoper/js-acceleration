\section{Introduction}\label{sec:introduction}
JavaScript(JS) has become one of the most widely used programming languages in the world \cite{JSSurvey}. However, it has not been widely adopted to perform scientific computing and data analysis by a community and maintainers for a long time. This includes the development of libraries and features of the language itself. JavaScript is a dynamically typed scripting language, evaluated in the runtime and has only single thread available to the developer in general. Released in 1995, it was executed only in an isolated sandbox environment of a web browser \cite{SpeakingJS} and was used mostly to add dynamic content to websites.

This has changed since more JS environments were released which was allowed by an evolution of JS engines. With the release of Node \cite{node} in 2009 we were able to run server-side code using V8 engine \cite{V8} from the Chromium project \cite{Chromium}. At this point, there were at least two ways of building libraries - one for the browser environment (AMD \cite{calhoun_2014}) and one for the CommonJS (CJS) \cite{CJS} format used by Node. With the release on ECMAScript 2015 \cite{ES6}, better known as the ES6 standard, the modularity of JS code was standardized as ESModules \cite{ESModules}. They are now supported by the vast majority of environments but with an ecosystem that big (1851301 npm packages as of 2022-01-19 \cite{module_counts}) it is still common to build and publish libraries in legacy formats. 

The reason why heavy computing in JS is not a popular solution is complex. First of all, slow evolution, the predefined and narrow purpose of the language at first has slowed down the efforts to adapt the language to the task of heavy computation. Secondly, not unified module format and differences between environments in the implementation of corresponding features were not encouraging the community to develop multi-platform libraries. Finally, in the meantime when JS was being developed in its way, other and more popular solutions like MatLab, Python, and R language were already around with their ecosystems (\cite{matlab}, \cite{oliphant2007python}, \cite{gerrard2015mastering}).


In this paper, we check the state of scientific and data analysis multi-platform computing potential in JS. We try to find how the same algorithm performs when implemented using multiple acceleration methods in popular JS environments with as few adjustments as possible for each method. We also want to find if all of these methods can be built into a single output format with the same library interface for maximum compatibility. We hope to find interesting facts and caveats about each analyzed environment and acceleration method.

\section{Related work}
Analyzing the problem we have to look at it from different perspectives. The first one is the performance of the native JS, specifically the performance of JS engines. We analyze performance of V8 and SpiderMonkey engines focusing on the first one. It was shown that simple optimizations, even changing one line of code, can increase performance due to the JIT optimizations in the runtime (\cite{meurer_2017}, \cite{meurer_2019}, \cite{gong2015jitprof}, \cite{selakovic2016performance}). With known  Thread-level speculation, could also be beneficial to the performance \cite{martinsen2017combining} but it is not implemented in common JS engines.

The second perspective is the performance of each environment. We analyze performance in web browsers - Chrome and Firefox with V8 and SpiderMonkey \cite{spidermonkey} as JS engine respectively. We also analyze the same code on server-side environments - Node and Deno \cite{Deno} with both using V8 as JS engine. Node, written in C++, has proven to be great environment for I/O heavy tasks outperforming other environments (\cite{lei2014performance}, \cite{chitra2017performance}). Deno, written in Rust, is a younger brother of Node providing a modern ecosystem with built-in support for ESModules and TypeScript. It keeps up the performance with Node with insignificant differences \cite{choubey_2021}.

The last aspect is the performance of acceleration methods in each environment. Analyzing CPU-heavy algorithm we want to adjust it and compare its performance against available acceleration methods in each environment. Multi-threading is available in each environment in some form of "Worker". Parallel execution increases performance as expected \cite{djarv2020performance} but this performance may differ between environments. 

Another way of increasing performance, this time in server-side environments, is to use native plugins which were developed primarily to allow usage of existing codebase written in other languages. Node and Deno use plugins that can be written in C++ \cite{cpp_addons} and Rust \cite{logrocket_blog_2021} respectively. The same reason for development stands behind WebAssembly(WASM) \cite{niessen2020webassembly}. It allows to compile and make any code portable across environments performing better than native JS. Yet the study shows, that depending on the case we can get mixed performance results (\cite{yan2021understanding}, \cite{jangda2019not}). 

The last analyzed method is the usage of GPGPU (General-purpose computing on graphics processing units). It involves tricky usage of the WebGL's graphics pipeline not to generate graphics, but using its advantages, executing algorithms that can be massively parallelized \cite{sapuan2018general}. The caveats of this method are slow data transfer between CPU and GPU, and lack of shared memory which is the characteristic of the pipeline itself. There were attempts of trying to standardize API specific to GPGPU (e.g. WebCL) and the most promising today is WebGPU \cite{webgpu_2022}.

It is important to mention the building ecosystem provides high compatibility and the possibility of transforming assets. In terms of heavy computing, it matters how the library is built, because some optimization or transpilation techniques may interfere with implementation specific to a particular acceleration method. We use Webpack \cite{webpack} as a module bundler with ESModule \cite{PALTOGLOU2021111049} as the desired output for each library built.
