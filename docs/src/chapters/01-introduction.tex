\chapter{Wstęp}

Prawo Moore'a mówi, że liczba tranzystorów w~układach scalonych podwaja się co około dwa lata. Prawo Koomey'a opisuje natomiast trend wzrostu liczby obliczeń na jeden dżul energii, która podwaja się co 1.57 lat. Choć w~ostatnich latach, w~związku ze zmniejszającym się tempem miniaturyzacji tranzystorów, wartości te przestały być aktualne to wciąż mamy do czynienia ze zjawiskiem ustawicznego wzrostu mocy obliczeniowej. Dodatkowo, zgodnie z~obserwacją nazwaną prawem Huang'a - prezesa firmy NVIDIA, wzrost wydajności układów graficznych wzrasta więcej niż dwukrotnie co dwa lata\cite{tongo}, co świadczy o~obecnym rozwoju możliwości optymalizacji architektur i~programów wykorzystujących przetwarzanie masowo równoległe.  Wzrost wydajności z~kolei zwiększa możliwości wykorzystania algorytmów, które wcześniej były zbyt intensywne obliczeniowo i~nie mogły być wykorzystane w~rozwiązaniach produkcyjnych. Powszechnie dostępne wydajne maszyny dają również możliwości szybszego prototypowania rozwiązań większej liczbie osób, co z~kolei wpływa na rozwój samych algorytmów i~ich zastosowań. Algorytmy i~obliczenia opierają się na osiągnięciach analizy numerycznej oraz matematyki dyskretnej.

Analiza numeryczna zajmuje się opisywaniem i~analizą metod pozyskiwania wyników dla problemów matematycznych. Dzięki jej osiągnięciom możliwe jest budowanie algorytmów, które są kompletnym i~jednoznacznym opisem metody konstruowania rozwiązania owych problemów. Konstruowane algorytmy mogą mieć różne poziomy skomplikowania zaczynając od obliczania wartości funkcji, wielomianów, czy też znajdować rozwiązania układów równań. Dzięki nim możemy aproksymować wartości funkcji - obliczać pochodne oraz całki korzystając z~metod prostokątów, trapezów, czy Simpson'a. Możemy obliczać przybliżenia funkcji trygonometrycznych korzystając z~szeregów Taylor'a. Dzięki obliczeniom opartym o~algebrę liniową i~rachunek różniczkowy mogły rozwinąć się pola związana z~uczeniem maszynowym. Znajdowanie wektorów i~wartości własnych macierzy w~metodzie PCA w~celu redukcji wymiarowości danych, a~w końcu algorytmy propagacji wstecznej szczególnie wykorzystywane w~intensywnie rozwijającym się obszarze uczenia głębokiego\cite{phillips1996theory}.

Niezależnie od skali zaawansowania algorytmów dążą one do stanowienia rozwiązania konkretnych problemów świata rzeczywistego. Przykładem ich zastosowania jest przewidywanie pogody w~oparciu o~modele meteorologiczne, które zaczęło intensywnie rozwijać się wraz z~dostępem do coraz większej mocy obliczeniowej i~udoskonalaniem samych modeli. W~ciągu 15 lat, od 1971 roku, spełnialność prognoz 36-godzinnych zrównała się ze spełnialnością prognoz 72-godzinnych\cite{lynch2008origins}. Kolejnym wartym przytoczenia przykładem jest obszar analizy obrazów z~wyszczególnieniem zagadnienia ich klasyfikacji, gdzie wzrost mocy obliczeniowej pozwolił na rozwój algorytmów. W~ciągu 8 lat metryka dokładności klasyfikacji obrazów na zbiorze danych ImageNet wzrosła z~63\% do 90\%\cite{lynch2008origins,dai2021coatnet}.

Dynamiczny rozwój algorytmów napędzany jest przede wszystkim przez poszerzanie i~budowanie wiedzy domenowej, specyficznej dla rozwiązywanego problemu. Jednak, aby uczynić taki rozwój możliwym, musi być on oparty na niezbędnych filarach jakimi są oprogramowanie, które służy do prototypowania, a~następnie wdrażania rozwiązań oraz środowisko sprzętowe, które umożliwia przeprowadzanie obliczeń, wielokrotnych testów, prototypów na małą oraz wdrożeń na dużą skalę. Wraz ze wzrostem złożoności problemu liczba obliczeń niezbędnych do jego rozwiązania również rośnie i~w przypadku ich większości ten wzrost jest wykładniczy lub większy. Niezbędnym zatem jest, aby oprogramowanie potrafiło wykorzystać wszelkie dostępne metody akceleracji zarówno te związane z~optymalizacją samego algorytmu, jak i~te związane z~mechanizmami akceleracji sprzętowej.

\section{Istota rzeczy}

Wykonywanie obliczeń numerycznych wśród obecnie popularnych rozwiązań można podzielić na dwie grupy. Pierwsza z~nich używa specjalnie do tego celu stworzonego języka programowania, często również w~połączeniu ze zintegrowanym środowiskiem programistycznym (Integrated Development Environment, ang. IDE). Przykładem takiego rozwiązania jest środowisko i~język MATLAB\cite{matlab} oraz R\cite{r}, czy też środowisko Mathematica z~językiem Wolfram\cite{mathematica}.

Druga grupa używa języka ogólnego przeznaczenia do wykonywania obliczeń w~oparciu o~zewnętrzne biblioteki w~zdecydowanej większości udostępniane jako oprogramowanie open-source, które dostarczają wymagany zestaw funkcjonalności niwelując potrzebę ich ręcznej implementacji. Języki takie możemy podzielić na te niskiego poziomu, zapewniające wysoką wydajność, oraz te wysokiego poziomu, interpretowane, zapewniające większą wygodę użytkowania. Najbardziej popularnym tego typu środowiskiem jest język Python, którego społeczność stworzyła liczne biblioteki (w postaci pakietów) do przetwarzania danych, obliczeń numerycznych i~statystycznych, analizy obrazów, czy uczenia maszynowego. Najpopularniejsze z~nich podane zostały w~tabeli \ref{tab:py-js}. W~nawiasach została ujęta liczba pobrań danego pakietu w~przeciągu ostatniego tygodnia na dzień 2022-04-27. Dla punktu odniesienia warto dodać, że w~przeciągu tego samego tygodnia, w~całym ekosystemie, pobrano łącznie 3.409.997.407 pakietów \cite{pypi-stats}.

Biblioteki takich języków, czego przykładem jest biblioteka OpenCV, często implementowane są w~językach kompilowanych bezpośrednio do kodu maszynowego takich jak C++ czy Rust udostępniając jednolity interfejs, którego metody, poprzez powiązania, wywoływać mogą języki skryptowe wysokiego poziomu, takie jak już wspomniany Python. Takie rozwiązania zapewnia możliwość zbudowania wersji biblioteki kompatybilnej z~wieloma środowiskami i~językami na podstawie jednego kodu bazowego, poddając adaptacji tylko elementy architektury integrującej bibliotekę niskopoziomową i~język wysokiego poziomu. Skompilowana biblioteka poddana może być również procesom optymalizacji, co zwiększyć może jej wydajność. Wadę takiego rozwiązania stanowi konieczność kompilowania biblioteki niskiego poziomu dla wielu systemów operacyjnych, czy architektur procesora. Taka kompilacja odbywać może się przed publikacją samej biblioteki, a~gotowe artefakty pobierane są przez użytkownika w~momencie instalacji. Kompilacja może odbywać się również bezpośrednio na maszynie użytkownika w~momencie instalacji.

% TODO: diagram abstrakcji  codebase - binding - js/python/etc

Opisany podział nie skłania do uznania przewagi jednej z~grup nad drugą w~żadnym z~aspektów. W~środowiskach specyficznych i~zintegrowanych brakujące funkcjonalności mogą zostać dodane przez twórców jako biblioteki standardowe języka oraz zaimplementowane przez społeczność w~bibliotekach języków ogólnego przeznaczenia. Obie grupy rozwiązań z~reguły są w~stanie działać w~środowisku tego samego systemu operacyjnego i~wchodzić w~interakcje z~tym samym sprzętem, i~wykorzystać idące za tym możliwości akceleracji obliczeń. Jednak nie wszystkie języki ogólnego przeznaczenia i~technologie zyskały jednakową popularność w~obszarze obliczeń numerycznych mimo swojej ogólnej popularności. Przykładem takowych są technologie webowe z~językiem JavaScript na czele.

\subsection{Duża i~rosnąca rola technologii webowych}

Technologie webowe zdefiniować można jako narzędzia i~techniki umożliwiające wymianę danych pomiędzy różnymi urządzeniami przez internet. Technologie webowe mogą występować i~spełniać różne zadania na wielu poziomach architektury aplikacji. W~przypadku architektury klient-serwer środowiskiem frontend'owym umożliwiającym wyświetlanie i~obsługę graficznego interfejsu użytkownika zwykle jest przeglądarka internetowa, gdzie za jego implementację na najniższym poziomie abstrakcji odpowiadają języki HTML, CSS i~JavaScript. Serwerem może być na przykład aplikacja komunikująca się z~klientem za pomocą API zaimplementowanego w~architekturze REST, czy też za pomocą języka zapytań GraphQL uruchamiana w~środowisku NodeJS. 

Warto zaznaczyć, że serwer, jak i~klient, nie muszą być zaimplementowane z~wykorzystaniem języka JavaScript by być uznawanym jako aplikacja webowa. Języki takie jak PHP, Python, Ruby, Java, czy C\# także oferują zaawansowane frameworki, jednak to język JavaScript, ze względu na historię swojego rozwoju ściśle powiązaną z~przeglądarką internetową, uważany jest jako główne narzędzie i~czynnik rozwoju technologii webowych zarówno w~części klienckiej jak i~serwerowej. Potwierdzają to badania, gdzie JavaScript w~2021 roku dziewiąty rok z~rzędu został wyłoniony jako najpopularniejsza technologia wśród developerów \cite{stack2021}.

\begin{table}
    \caption{Popularne biblioteki do przetwarzania danych w~języku Python i~ich odpowiedniki w~języku JavaScript. Dane pochodzą z~serwisów kolejno PyPI Stats oraz NPM, a~w~nawiasach znajduje się tygodniowa liczba pobrań biblioteki.}
    \centering
    \renewcommand\arraystretch{1.2}
    \begin{tabularx}{\linewidth}[t]{p{5cm} p{4.5cm} X}
        \bfseries{Python} & \bfseries{JavaScript} & \bfseries{Zastosowanie} \\ \hline
        numpy (26.067.844) & numjs (533) & Operacje na macierzach \\ \hline
        pandas (19.778.648) & danfojs (1.029) & Operacje na strukturach danych \\ \hline
        scipy (9.986.376) & simple-statistics (87.882) \newline fft.js (8.027) & Operacje związane z~analizą numeryczną, przetwarzanie sygnałów, algebra liniowa. \\ \hline
        scikit-learn (7.705.438) & ml (156) & Uczenie maszynowe \\ \hline
        matplotlib (6.457.099) \newline plotly (1.632.246) & plotly.js (149.542) \newline c3 (83.564) & Wizualizacja danych \\ \hline
        tensorflow (3.348.986) & @tensorflow/tfjs (91.233) & Sieci neuronowe \\ \hline
        opencv-python (1.236.711) & OpenCV.js (b.d \cite{cv2-js}) \newline jimp (1.479.783) \newline image-js (4.103)        & Operacja na obrazach, computer vision \\ \hline

    \end{tabularx}
    \label{tab:py-js}
\end{table}

\subsubsection{JavaScript w~obliczeniach numerycznych}

Pomimo swojej popularności, w~przeciwieństwie do języka Python, język JavaScript nie zyskał popularności wśród zadań obliczeń inżynierskich, naukowych, statystycznych, obróbki i~analizy obrazów. Jest on starszy od języka JavaScript i~w przeciwieństwie do niego od początku mógł pełnić zadanie narzędzia do implementacji algorytmów obliczeniowych, podczas gdy JavaScript ograniczony był jedynie do jednowątkowego środowiska przeglądarki internetowej. Dopiero w~2009 roku, wraz z~pojawieniem się środowiska NodeJS, możliwe stało się uruchamianie kodu JavaScript po stronie serwera. Umożliwia to również powstały w~2018 roku środowisko Deno. 

Innym czynnikiem, który warunkuje tempo rozwoju i~potencjalny przepływ użytkowników ku lepszym ich zdaniem środowiskom jest dostępność metod akceleracji obliczeń, która warunkuje możliwości poprawy wydajności. W~konsekwencji przekłada się to na wygodę użytkowania i~możliwości prototypowania bardziej złożonych algorytmów dla problemów o~większych rozmiarach. Przykładem takich są algorytmy uczenia maszynowego, w~szczególności uczenia głębokiego.

Ostatnim z~analizowanych czynników jest architektura systemu pakietów, która jest ściśle powiązana ze środowiskami uruchomieniowymi, które z~nich korzystają. Pobierane pakiety zawierają biblioteki, które importowane są do projektu w~postaci modułów. Python posiada jeden format modułów w~przeciwieństwie do języka JavaScript ze względu na heterogeniczność środowisk jego wykonywania. Przeglądarka internetowa, NodeJS i~Dino mimo, że wykonują kod w~tym samym języku, posiadają znaczące różnice w~sposobie komunikacji z~użytkownikiem, systemem operacyjnym, w~dostępności metod akceleracji i~zarządzaniu modułami. Rodzi to problemy 

Obecnie jednak, z~technicznego punktu widzenia, nie istnieją zasadnicze różnice pomiędzy środowiskami języków Python i~JavaScript, które hamowałyby w~znacznym stopniu rozwój bibliotek służącym do prototypowania i~wdrażania aplikacji zajmującymi się obliczeniami numerycznymi w~środowiskach języka JavaScript.

W tabeli \ref{tab:py-js} przedstawiono porównanie popularnych bibliotek stosowanych przy obliczeniach numerycznych języka Python z~ich odpowiednikami w~języku JavaScript. Widać wyraźnie dysproporcję w~liczbie pobrań bibliotek pomiędzy językami. W~wielu przypadkach autorowi nie udało się znaleźć dokładnego odpowiednika danej biblioteki, a~znalezione zestawy bibliotek języka JavaScript nie pokrywają w~całości funkcjonalności biblioteki języka Python.

% https://github.com/iodide-project/awesome-browser-data-science-libraries#mathstatistics
% https://stackoverflow.com/questions/31412537/numpy-like-package-for-node

\section{Cel badań i~zawartość pracy}

\input{tables/implemented}
 
Celem niniejszej pracy jest zbadanie przystosowania środowisk języka JavaScript do przeprowadzania obliczeń numerycznych oraz wykonywania złożonych algorytmów. Analizie poddano popularne środowiska - NodeJS, Deno i~przeglądarki internetowe Google Chrome i~Mozilla Firefox. Dla tych środowisk zbadano dostępne metody akceleracji obliczeń, gdzie pojęcie akceleracji rozumiane jest jako każda modyfikacja algorytmu wpływająca pozytywnie na jego wydajność. Tyczy się to optymalizacji wersji sekwencyjnej algorytmu bez zmiany jego złożoności, jak i~jego modyfikację do wersji zrównoleglonej. Metody akceleracji zaimplementowane dla badanych środowisk przedstawione zostały w~tabeli \ref{tab:implemented}. Zostaną one opisane dokładnie w~dalszej części pracy. Analiza zorientowana jest na algorytmy analizy obrazów.


Na to złożone zagadnienie trzeba spojrzeć z~wielu perspektyw. Autor pracy abstrahuje jednak od zagadnienia poprawy złożoności obliczeniowej samego algorytmu w~wersji sekwencyjnej, ponieważ rozważania takie wykraczają poza zakładaną w~pracy tematykę, która koncentruje się na środowiskach języku JavaScript i~możliwościach tych środowisk, jak i~samego języka.

\subsection{Perspektywa wydajności}

Pierwszą z~perspektyw jest wydajność algorytmu postrzegana przez pryzmat środowiska, w~którym jest on wykonywany oraz wykorzystywanych przez niego metod akceleracji. W~pracy zbadano wydajność zaimplementowanego algorytmu z~wykorzystaniem metod wymienionych w~tabeli~\ref{tab:implemented}, które szczegółowo omówione zostały w~rozdziale \ref{sec:acc-methods}.

\subsection{Perspektywa kompatybilności i~budowania bibliotek}

Innym punktem widzenia jest kompatybilność budowanych bibliotek w~wielu środowiskach. Jednak każde z~nich jest na tyle zróżnicowane, że zbudowanie jednej wersji kodu źródłowego kompatybilnego z~nimi wszystkimi naraz jest wymagające, a~niekiedy niemożliwe. Analiza tego zagadnienia, możliwości i~ograniczeń modularności kodu języka JavaScript, dodatkowo w~aspekcie wykorzystywanych metod akceleracji, opisana została w~rozdziale \ref{sec:env-modules}.

\subsection{Perspektywa wygody użytkowania}

Celem autorów bibliotek jest dostarczenie rozwiązań, które przede wszystkim będą aktywnie wykorzystywane. Autor, razem z~opisem implementacji algorytmów i~ich późniejszego wykorzystania, w~rozdziale \ref{sec:implementation} analizuje możliwości i~sposoby interakcji ze środowiskami, wyświetlanie wyników, ładowanie danych oraz wewnętrzne mechanizmy przetwarzania danych związane również z~modelem wykonania języka JavaScript.

\subsection{Transformacja Hough'a jako wspólny mianownik analizy}

W celu porównania wydajności pomiędzy środowiskami dla tej samej metody akceleracji oraz porównania ich w~ramach jednego środowiska zaimplementowano algorytmy transformacji Hough'a (czyt. Haf'a), która dokładniej opisana został w~rozdziale \ref{sec:hough}. Jest to rodzina algorytmów deterministycznych wykorzystywana do detekcji kształtów parametrycznych i~nieparametrycznych na obrazach.  Własna implementacja algorytmów z~tej rodziny, w~przeciwieństwie do zestawów testowych takich jak na przykład Ostrich\cite{ostrich}, daje możliwości granularnej kontroli nad samą implementacją i~możliwości dostosowania jej do wszystkich analizowanych środowisk i~metod akceleracji. Samo wykrywanie kształtów na podstawie transformacji Hough'a jest intensywne obliczeniowo, wieloetapowe, wykorzystuje operacje zmiennoprzecinkowe, w~tym funkcje trygonometryczne, oraz zakłada wykonanie wielu iteracji po dużych, zależnych od rozmiaru problemu i~próbkowania, strukturach danych. Czynniki te czynią tę rodzinę algorytmów, zdaniem autora, dobrym punktem zaczepienia podczas szerokiej analizy środowisk i~metod akceleracji, które one udostępniają, co pozwala uzyskać ogólną orientację w~analizowanych perspektywach oraz wskazać wartościowe kierunki przyszłych badań. 

\subsection{Zawartość pracy}

Rozdział drugi opisuje język JavaScript, wprowadza w~zagadnienie jego modelu wykonania, środowisk oraz opisuje dostępne dla nich metody akceleracji i~sposoby budowania bibliotek. Wspólny mianownik analizy, czyli algorytmy transformacji Hough'a i~sposób ich działania opisany został w~rozdziale trzecim. Rozdział czwarty opisuje metodykę przeprowadzanych testów wydajności, dla potrzeb których zaimplementowana została osobna biblioteka odpowiedzialna za pomiary czasu wykonania, mając na uwadze jej kompatybilność ze wszystkimi środowiskami. Implementację algorytmów i~konsekwencje idące za stosowaniem poszczególnych rozwiązań opisuje rozdział piąty. Rozdział szósty przedstawia rezultaty testów wydajności ze wskazaniem na porównanie środowisk i~metod do bazowych wariantów sekwencyjnego wykonania algorytmu, a~rozdział siódmy stanowi podsumowanie całości rozważań i~eksperymentów oraz wskazuje zidentyfikowane problemy i~proponowane kierunki przyszłych badań.
